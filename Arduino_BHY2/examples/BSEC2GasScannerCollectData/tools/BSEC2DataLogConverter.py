from datetime import timezone
import datetime
import sys
import os
import json

# =~=~=~=~=~=~=~=~=~=~=~= PuTTY log 2022.10.21 08:32:17 =~=~=~=~=~=~=~=~=~=~=~=
# 245166 31.27 102027.92 35.10 2049537.13 5

# this script converts the data log generated by the Arduino_BHY2/BSEC2GasScanningCollectData.ino example sketch
# to data format acceptable by the BME AI Studio for the training of AI models

class BSEC2DataLogConverter():
    # sometimes you may want to add an offset to the converted data in situations such as reset of the board, this way
    # the converted data contains timestamp that will succeed earlier log files,
    # otherwise, there will be overlap of timestamp ranges among the converted data which might confuse the AI studio software
    def __init__(self, log_file_name, gas_label, bmeconfig_file, timestamp_offset_ms = 0, dbg=False):
        self.log_file_name = log_file_name
        self.log_file = open(self.log_file_name, 'r')
        self.lines = self.log_file.readlines()
        self.log_time_start = None
        self.log_timestamp_start = 0
        self.rawdata = []
        self.gas_label = int(gas_label)
        self.bmeconfig_file = bmeconfig_file 
        self.timestamp_offset_ms = timestamp_offset_ms
        self.dbg = dbg
        if len(self.lines) < 3:
            sys.exit("Err: There's too little data in log")
        self._clean_data()
        self.check_gas_index_missing()

    def _clean_data(self):
        # Putty's default log has header which contains the time when the log was created
        if "PuTTY" in self.lines[0]:
            # 2022.10.21 07:31:17
            self.log_time_start = self.lines[0].split(" ")[3] + " " + self.lines[0].split(" ")[4]

        lines_clean = []
        for line in self.lines[1:]:
            if len(line.split(' ')) == 6:
                lines_clean.append(line)
                #print('line:', '"', line, '"', sep='')
        self.lines = lines_clean

    def toString(self):
        print(self.lines)

    def check_gas_index_missing(self):
        last_index = int(self.lines[0].split(' ')[-1])
        #for i, line in enumerate(self.lines[1:]):
        for i, line in enumerate(self.lines[1:-1]):
            if self.dbg:
                print('dbg:', i, ':"', line, '"', sep='')
            cur_index = int(line[-2:-1])
            # print(cur_index)
            if (cur_index - last_index != 1) and (cur_index - last_index != -9):
                print("Missing gas index at line {}, {} {}".format(i+1, cur_index, last_index))
            last_index = cur_index

    def _get_timestamp_start(self, line):
        infos = line.split(' ')
        timestamp_ms_start = int(infos[0])
        return timestamp_ms_start

    def unpack_data(self, line):
        infos = line.split(' ')
        timestamp_ms = int(infos[0])  +  self.timestamp_offset_ms
        temp = float(infos[1])
        pres = float(infos[2])
        hum = float(infos[3])
        gas = float(infos[4])
        gas_index = int(infos[5])
        return (timestamp_ms, temp, pres, hum, gas, gas_index)

    def format_data(self, Ttphg, time_start_s, label, sensor_index=0, sensor_id=1730555495, scanning_mode_ena=1, error_code=0):
        '''
            Ttphg: timestamp_ms, temp, pres, hum, gas, gas_index
        '''
        return (sensor_index, sensor_id, Ttphg[0], time_start_s + Ttphg[0]//1000 - self.log_timestamp_start // 1000,
                Ttphg[1], Ttphg[2], Ttphg[3], Ttphg[4], Ttphg[5], scanning_mode_ena, label, error_code)

    def parse(self):
        if self.log_time_start:
            dt = datetime.datetime.strptime(self.log_time_start[2:], "%y.%m.%d %H:%M:%S") 
            utc_timestamp = int(dt.timestamp())
        else:
            dt = datetime.datetime.now(timezone.utc)
            utc_time = dt.replace(tzinfo=timezone.utc)
            utc_timestamp = int(utc_time.timestamp())

        self.log_timestamp_start = self._get_timestamp_start(self.lines[0])
        for line in self.lines:
            # print(line)
            data_unformated = self.unpack_data(line)
            data_formated = self.format_data(data_unformated, utc_timestamp, self.gas_label)
            # print(data_formated)
            self.rawdata.append(data_formated)


    def _modify_incompatible_keys(self, cfg):
        cfg["configHeader"]["dateCreated"] = ""
        return cfg

    def _add_raw_data_header(self, cfg):
        rawDataHeader = {
                        "counterPowerOnOff": 1,
                        "seedPowerOnOff": "",
                        "counterFileLimit": 1,
                        "dateCreated": "",
                        "dateCreated_ISO": "",
                        "firmwareVersion": "0",
                        "boardId": "1730555495"
                    }
        cfg["rawDataHeader"] = rawDataHeader
        return cfg

    def _add_raw_data_body(self, cfg, data_list):
        dataColumns = [
            {
            "name": "Sensor Index",
            "unit": "",
            "format": "integer",
            "key": "sensor_index"
            },
            {
            "name": "Sensor ID",
            "unit": "",
            "format": "integer",
            "key": "sensor_id"
            },
            {
            "name": "Time Since PowerOn",
            "unit": "Milliseconds",
            "format": "integer",
            "key": "timestamp_since_poweron"
            },
            {
            "name": "Real time clock",
            "unit": "Unix Timestamp: seconds since Jan 01 1970. (UTC); 0 = missing",
            "format": "integer",
            "key": "real_time_clock"
            },
            {
            "name": "Temperature",
            "unit": "DegreesCelcius",
            "format": "float",
            "key": "temperature"
            },
            {
            "name": "Pressure",
            "unit": "Hectopascals",
            "format": "float",
            "key": "pressure"
            },
            {
            "name": "Relative Humidity",
            "unit": "Percent",
            "format": "float",
            "key": "relative_humidity"
            },
            {
            "name": "Resistance Gassensor",
            "unit": "Ohms",
            "format": "float",
            "key": "resistance_gassensor"
            },
            {
            "name": "Heater Profile Step Index",
            "unit": "",
            "format": "integer",
            "key": "heater_profile_step_index"
            },
            {
            "name": "Scanning Mode Enabled",
            "unit": "",
            "format": "integer",
            "key": "scanning_mode_enabled"
            },
            {
            "name": "Label Tag",
            "unit": "",
            "format": "integer",
            "key": "label_tag"
            },
            {
            "name": "Error Code",
            "unit": "",
            "format": "integer",
            "key": "error_code"
            }
        ]
        rawDataBody = {
            "dataColumns": dataColumns,
            "dataBlock": data_list
        }

        cfg["rawDataBody"]= rawDataBody

        return cfg

    def gen_ai_studio_training_data(self):
        bme_cfg = json.loads(open(self.bmeconfig_file, "r").read())
        bme_cfg = self._modify_incompatible_keys(bme_cfg)
        bme_cfg = self._add_raw_data_header(bme_cfg)
        bme_cfg = self._add_raw_data_body(bme_cfg, self.rawdata)
        cfg_str = json.dumps(bme_cfg, indent=4)
        #filename = self.bmeconfig_file.split(".")[0] + "_gas_" + str(self.gas_label) + ".bmerawdata"
        file_name_base = os.path.basename(self.log_file_name)
        path_folder = os.path.dirname(self.log_file_name)
        filename_wo_ext = os.path.splitext(file_name_base)[0]

        filename = path_folder + '/' + "_gas_" + str(self.gas_label) + '_' + filename_wo_ext + ".bmerawdata"
        if self.dbg:
            print("dbg: path_folder:", path_folder)
            print("dbg: filename_wo_ext:", filename_wo_ext)
            print("dbg: filename:", filename)

        bmerawdata_file = open(filename, "w")
        bmerawdata_file.write(cfg_str)
        print('bmedata: ', '"'+filename+'"', 'generated')


if __name__ == '__main__':
    """
        Make sure to change gas_label if you collect multiple gas, choose from 0,1,2,3.
    """
    if (len(sys.argv) < 4):
        print("usage:")
        print("\tpython", sys.argv[0], "LOG_FILENAME GAS_LABEL_NUMBER BME_CONFIG_FILE")
        print("\t\t GAS_CLASS_NUMBER is a number between 0-3 which is mapped to class A-D in the algorithm settings of BME AI Studio")
        print("\t\t BME_CONFIG_FILE is a board config file generated by BME AI Studio Software")
        print("example:")
        print("\tpython", sys.argv[0], "./datalog/session3-room2/ambient-air.log", "0", "./NiclaSenseME_BoardConfiguration.bmeconfig")
        raise BaseException("missing argument")
    else:
        parser = BSEC2DataLogConverter(log_file_name = sys.argv[1], gas_label = sys.argv[2], bmeconfig_file = sys.argv[3])

    parser.parse()
    """
        Pass the path of the bmeconfig file generated by the BME AI Studio,
        and this script will generate 2022_10_21_15_13_BoardConfiguration{gas_label}.bmerawdata for you
    """
    parser.gen_ai_studio_training_data()

